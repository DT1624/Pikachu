#include <bits/stdc++.h>
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_mixer.h>
#include <SDL_ttf.h>
#include <ctime>

using namespace std;

const int SCREEN_WIDTH = 1100;
const int SCREEN_HEIGHT = 750;
const int row = 18;
const int collum = 11;
const int h_w = 50;
const string WINDOW_TITLE = "PIKACHU";
const int FRAME_DELAY = 50;
const int FPS = 20;
const int lv_time = 600;

int arr[collum][row] = {0};
string photos[25];
SDL_Window* window = NULL;
SDL_Renderer* renderer = NULL;
int const_row = 2 * h_w;
int const_collum = 3 * h_w / 2;
bool check = true;
bool lose = false;
int score = 0;
int turn = 10;
int level = 1;
int sound = 0;
int time_lv = lv_time;
Mix_Music *gMusic;
map<int, int> m;
int time_end[100] = {0};

void logSDLError(ostream& os, const string &msg, bool fatal = false)
{
  os << msg << "Error: " << SDL_GetError() << endl;
  if(fatal)
  {
    SDL_Quit();
    exit(1);
  }
}

void initSDL(SDL_Window* &window, SDL_Renderer* &renderer)
{
  if(SDL_Init(SDL_INIT_EVERYTHING) != 0) logSDLError(cout, "SDL_Init", true);

  window = SDL_CreateWindow(WINDOW_TITLE.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
  //window = SDL_CreateWindow(WINDOW_TITLE.c_str(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN_DESKTOP);
  if(window == nullptr) logSDLError(cout, "CreateWindow", true);
  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
  Mix_OpenAudio( 44100, MIX_DEFAULT_FORMAT, 2, 2048 );

  SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
  SDL_RenderSetLogicalSize(renderer, SCREEN_WIDTH, SCREEN_HEIGHT);
  //SDL_RenderSetScale(renderer, 1920 / SCREEN_WIDTH, 1080 / SCREEN_HEIGHT);
}

void quitSDL(SDL_Window* window, SDL_Renderer* renderer)
{
  SDL_DestroyRenderer(renderer);
  SDL_DestroyWindow(window);
  SDL_Quit();
  IMG_Quit();
  TTF_Quit();
  Mix_Quit();
}

void waitUntilKeyPressed()
{
  SDL_Event e;
  while(true)
  {
    if(SDL_WaitEvent(&e) != 0 && (e.type == SDL_KEYDOWN || e.type == SDL_QUIT)) return;
    SDL_Delay(100);
  }
}

SDL_Texture* loadTexture(string path, SDL_Renderer* renderer){
    SDL_Texture* newTexture = nullptr;
    SDL_Surface* loadedSurface = IMG_Load(path.c_str());
    if(loadedSurface == nullptr){
        cout<<"Unable to  load image " << path << " SDL_image Error: "
        << IMG_GetError() << endl;
    }
    else{
        newTexture = SDL_CreateTextureFromSurface(renderer, loadedSurface);
        if(newTexture == nullptr)
            cout<<"Unable to create texture from " << path << " SDL Error: "
                << SDL_GetError()<< endl;
                SDL_FreeSurface( loadedSurface);
    }
    return newTexture;
    SDL_DestroyTexture(newTexture);
    SDL_FreeSurface(loadedSurface);
}

void renderTexture(string path, int x, int y, int w, int h)
{
	SDL_Rect rect = {x, y, w, h};
  SDL_Texture *file = loadTexture(path.c_str(), renderer);
  if(file == nullptr) {
    SDL_DestroyTexture(file);
    quitSDL(window, renderer);
    //break;
  }
	SDL_RenderCopy(renderer, file, NULL, &rect);
	SDL_DestroyTexture(file);
}

void drawCircle(SDL_Renderer* renderer, int x, int y, int r)
{
    SDL_SetRenderDrawColor(renderer, 255, 20, 255, 255);
    for(double i = -r / sqrt(2); i <= r / sqrt(2); i += 0.01)
    {
        SDL_RenderDrawPoint(renderer, x + i, y + sqrt(r * r - i * i));
        SDL_RenderDrawPoint(renderer, x + i, y - sqrt(r * r - i * i));
    }
    for (float i = -r/sqrt(2); i <= r/sqrt(2); i += 0.2)
    {
        SDL_RenderDrawPoint(renderer, x + sqrt(r * r - i * i), y + i);
        SDL_RenderDrawPoint(renderer, x - sqrt(r * r - i * i), y + i);
    }
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
}

void reset_img()
{
  SDL_Rect rect = {1025, 25, 50, 50};
  SDL_Texture *abc = loadTexture("photos/reset.png", renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect);
  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(abc);
}

void main_img()
{
  SDL_Rect rect = {950, 25, 50, 50};
  SDL_Texture *abc = loadTexture("photos/main.png", renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect);
  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(abc);
}

void sound_img()
{
  SDL_Rect rect = {875, 25, 50, 50};
  SDL_Texture *abc;
  if(sound == 0) abc = loadTexture("photos/sound.png", renderer);
  else abc = loadTexture("photos/pause_sound.png", renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect);
  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(abc);
}

void mix()
{
  sound = (sound + 1) % 2;
  sound_img();
  if( Mix_PlayingMusic() == 0 )
  {
    Mix_PlayMusic( gMusic, -1 );
  }
  else
  {
    if( Mix_PausedMusic() == 1 )
    {
      Mix_ResumeMusic();
    }
    else
    {
      Mix_PauseMusic();
    }
  }
}

void loadMedia()
{
  gMusic = Mix_LoadMUS( "sound/pika1.mp3" );
	if( gMusic == NULL )
	{
		printf( "Failed to load beat music! SDL_mixer Error: %s\n", Mix_GetError() );
		Mix_Quit();
	} else Mix_PlayMusic(gMusic , -1);
}

void loadChunk()
{
  Mix_Chunk *gMedium = Mix_LoadWAV( "sound/medium.wav" );
	Mix_PlayChannel( -1, gMedium, 0 );
}

void loadFont_start()
{
	TTF_Font* font = NULL;
	SDL_Surface* surface = NULL;
	SDL_Texture* texture = NULL;

	//Initialize the truetype font API.
	if (TTF_Init() < 0)
	{
		SDL_Log("%s", TTF_GetError());
		SDL_Quit();
	}

	font = TTF_OpenFont("font/verdanab.ttf", 110);
	SDL_Color fg = {50, 100, 200};
  string text = "PIKACHU";

	surface = TTF_RenderText_Solid(font, text.c_str(), fg);
	texture = SDL_CreateTextureFromSurface(renderer, surface);
	SDL_FreeSurface(surface);

	SDL_Rect srcRest;
	SDL_Rect desRect;

  TTF_SizeText(font, text.c_str(), &srcRest.w, &srcRest.h);
	srcRest.x = 0;
	srcRest.y = 0;

	desRect.x = 285;
	desRect.y = 300;
	desRect.w = srcRest.w;
	desRect.h = srcRest.h;

  SDL_RenderCopy(renderer, texture, &srcRest, &desRect);
  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(texture);
}

void loadFont(string path, int x, int y, int w, int h, int n)
{
	if (TTF_Init() < 0)
	{
		SDL_Log("%s", TTF_GetError());
		SDL_Quit();
	}

  TTF_Font *font = TTF_OpenFont("font/ariblk.ttf", 50);
  int a = 0, b, c = 255;
  if(n == 0)
  {
    b = 0;
  } else if(n == 1) b = 250;
  else
  {
    a = rand() % 255;
    b = rand() % 255;
    c = rand() % 255;
  }
	SDL_Color fg = {a, b, c};

	SDL_Surface *surface = TTF_RenderText_Solid(font, path.c_str(), fg);
	SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
	SDL_FreeSurface(surface);

	SDL_Rect srcRest;
	SDL_Rect desRect = {x, y, w, h};;

  TTF_SizeText(font, path.c_str(), &srcRest.w, &srcRest.h);
	srcRest.x = 0;
	srcRest.y = 100;

  SDL_RenderCopy(renderer, texture, NULL, &desRect);
  SDL_RenderPresent(renderer);
  font = NULL;
  SDL_DestroyTexture(texture);
}

void background(const string &file)
{
  SDL_RenderClear(renderer);

  SDL_Texture *background = loadTexture(file.c_str(), renderer);
  SDL_Rect rect = {0, 0, SCREEN_WIDTH, SCREEN_HEIGHT};
  SDL_RenderCopy(renderer, background, NULL, &rect);

  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(background);
}

//tạo các điểm
struct Point
{
  public:
  int x;
  int y;
};

//đọc mảng từ file đã có
void makeArr()
{
  srand(time(NULL));

  vector<Point> point;
  vector<int> val;

  for(int i = 1; i <= collum - 2; i++)
  {
    for(int j = 1; j <= row - 2; j++)
    {
      point.push_back({i, j});
    }
  }

  for(int i = 1; i <= 36; i++)
  {
    for(int j = 1; j <= 4; j++)
      {
        val.push_back(i);
      }
  }

  random_shuffle(val.begin(), val.end());
  random_shuffle(val.begin(), val.end());

  int n = val.size();
  for(int i = 0; i < n; i++)
  {
      arr[point[i].x][point[i].y] = val[i];
  }
}

void random()
{
  vector<Point> point;
  vector<int> val;

  for(int i = 1; i <= collum - 2; i++)
  {
    for(int j = 1; j <= row - 2; j++)
    {
      if(arr[i][j] > 0)
      {
        point.push_back({i, j});
        val.push_back(arr[i][j]);
      }
    }
  }

  random_shuffle(val.begin(), val.end());
  random_shuffle(val.begin(), val.end());

  for(int i = 0; i < point.size(); ++i)
  {
      arr[point[i].x][point[i].y] = val[i];
  }
}


vector<pair<Point, Point>> checkX(Point A, Point B) {
  vector<pair<Point, Point>> st_A;
  //nếu 2 ô cùng cột thì ta sẽ xét đường đi theo hàng
  if(A.y == B.y || arr[A.x][A.y] != arr[B.x][B.y] || arr[A.x][A.y] * arr[B.x][B.y] == 0) return st_A;
  int minX_A = A.x, maxX_A = A.x;
  int minX_B = B.x, maxX_B = B.x;
  for(int i = A.x - 1; i >= 0; --i)
  {
    if(arr[i][A.y] == 0) minX_A = i;
    else break;
  }
  for(int i = B.x - 1; i >= 0; --i)
    {
    if(arr[i][B.y] == 0) minX_B = i;
    else break;
  }
  for(int i = A.x + 1; i < collum; ++i)
  {
    if(arr[i][A.y] == 0) maxX_A = i;
    else break;
  }
  for(int i = B.x + 1; i < collum; ++i)
  {
    if(arr[i][B.y] == 0) maxX_B = i;
    else break;
  }
  if(minX_A > maxX_B || maxX_A < minX_B) return st_A;
  bool check;
  int min_max = min(maxX_A, maxX_B);
  int max_min = max(minX_A, minX_B);
  for(int i = min(min_max, max_min); i <= max(min_max, max_min); ++i)
  {
    check = true;
    for(int j = min(A.y, B.y) + 1; j <= max(A.y, B.y) - 1; ++j)
    {
      if(arr[i][j] != 0) check = false;
    }
    if(check)
    {
      st_A.push_back({{i, A.y}, {i, B.y}});
    }
  }
  return st_A;
}

vector<pair<Point, Point>> checkY(Point A, Point B) {
  vector<pair<Point, Point>> st_A;
  //nếu 2 ô cùng hàng thì ta sẽ xét đường đi theo cột
  if(A.x == B.x || arr[A.x][A.y] != arr[B.x][B.y] || arr[A.x][A.y] * arr[B.x][B.y] == 0) return st_A;
  int minY_A = A.y, maxY_A = A.y;
  int minY_B = B.y, maxY_B = B.y;
  for(int i = A.y - 1; i >= 0; --i)
  {
    if(arr[A.x][i] == 0) minY_A = i;
    else break;
  }
  for(int i = B.y - 1; i >= 0; --i)
    {
    if(arr[B.x][i] == 0) minY_B = i;
    else break;
  }
  for(int i = A.y + 1; i < row; ++i)
  {
    if(arr[A.x][i] == 0) maxY_A = i;
    else break;
  }
  for(int i = B.y + 1; i < row; ++i)
  {
    if(arr[B.x][i] == 0) maxY_B = i;
    else break;
  }
  if(minY_A > maxY_B || maxY_A < minY_B) return st_A;
  bool check;
  int min_max = min(maxY_A, maxY_B);
  int max_min = max(minY_A, minY_B);
  for(int i = min(min_max, max_min); i <= max(min_max, max_min); ++i)
  {
    check = true;
    for(int j = min(A.x, B.x) + 1; j <= max(A.x, B.x) - 1; ++j)
    {
      if(arr[j][i] != 0) check = false;
    }
    if(check)
    {
      st_A.push_back({{A.x, i}, {B.x, i}});
    }
  }
  return st_A;
}

pair<Point, Point> road(Point A, Point B)
{
  vector<pair<Point, Point>> s1 = checkX(A, B);
  vector<pair<Point, Point>> s2 = checkY(A, B);
  pair<Point, Point> d = {A, B};
  int sum = 100;
  for(auto c : s2) s1.push_back(c);
  for(auto c : s1)
  {
    Point A1 = c.first;
    Point B1 = c.second;
    int ans = abs(A.x - A1.x + A.y - A1.y) + abs(A1.x - B1.x + A1.y - B1.y) + abs(B1.x - B.x + B1.y - B.y) + 1;
    if(ans < sum)
    {
      sum = ans;
      d = {A1, B1};
    }
  }
  return d;
}

bool check_Exit_Pair()
{
  vector<Point> point;
  for(int i = 1; i <= collum - 2; i++)
  {
    for(int j = 1; j <= row - 2; j++)
    {
      if(arr[i][j] > 0) point.push_back({i, j});
    }
  }

  for(int i = 0; i < point.size(); i++)
  {
    for(int j = i + 1; j < point.size(); j++)
    {
      Point A = {point[i].x, point[i].y};
      Point B = {point[j].x, point[j].y};
      if(checkX(A, B).size() != 0 || checkY(A, B).size() != 0) return true;;
    }
  }
  return false;
}

//kiểm tra bảng đã hết hay chưa
bool isGameOver() {
  for(int i = 0; i < collum; ++i)
  {
    for(int j = 0; j < row; ++j)
    {
      if(arr[i][j] > 0) return false;
    }
  }
  return true;
}

void load_time(int time)
{
  //SDL_RenderClear(renderer);
  renderTexture("photos/bgr_score.jpg", 850, 600, 150, 90);
  drawCircle(renderer, 930, 645, 45);
  drawCircle(renderer, 930, 645, 44);
  drawCircle(renderer, 930, 645, 43);
  drawCircle(renderer, 930, 645, 42);
  loadFont(to_string(time), 900, 600, 60, 90, 2);
}


//trả về địa chỉ của con trỏ vừa thực hiện
Point mouse()
{
  SDL_Event e;
  bool kt = true;
  int x = -1, y = -1;
  time_t nowtime = time(NULL);
  if(m[nowtime - time_end[level - 1]] == 0)
  {
    //cout << level << " " << time_end[level - 1] << " ";
    m[nowtime - time_end[level - 1]]++;
    if(time_lv - (nowtime - time_end[level - 1]) < 0)
    {
      lose = true;
      return {-1, -1};
    }
    load_time(time_lv - (nowtime - time_end[level - 1]));
    //cout << time_lv - (nowtime - time_end[level - 1]) << endl;
  }
  while(kt && SDL_PollEvent(&e))
  {
    if(e.type == SDL_QUIT)
    {
      check = false;
      SDL_Quit();
      break;
    }
    if(e.type == SDL_MOUSEBUTTONUP)
    {
      x = e.button.x;
      y = e.button.y;
      if(x >= 0 && y >= 0 && y <= SCREEN_HEIGHT && x <= SCREEN_WIDTH)
      {
        if(x >= 200 && x <= 250 && y >= 600 && y <= 650) {
          return {11, 4};
          kt = false;
          break;
        }
        if(x >= 950 && x <= 1000 && y >= 25 && y <= 75)
        {
          return{0, 20};
          kt = false;
          break;
        }
        if(x >= 1025 && x <= 1075 && y >= 25 && y <= 75)
        {
          return{0, 19};
          kt = false;
          break;
        }
        if(x >= 875 && y >= 25 && y <= 75 && x <= 925)
        {
          return {0, 18};
          kt = false;
          break;
        }
        x -= const_collum;
        x = (x + h_w - 1) / h_w;
        y -= const_row;
        y = (y + h_w - 1) / h_w;
        if(x >= 1 && y >= 1 && y <= collum - 2 && x <= row - 2 && arr[y][x] > 0)
        {
          return {y, x};
          kt = false;
          break;
        }
      }
    }
  }
  return {-1, -1};
}

int Ox(int n)
{
  n = (n - 1) * h_w + const_row + h_w / 2;
  return n;
}

int Oy(int n)
{
  n = (n - 1) * h_w + const_collum + h_w / 2;
  return n;
}



void print_Road(Point A, Point B)
{
  pair<Point, Point> p = road(A, B);
  Point B1 = p.second;
  Point A1 = p.first;
  SDL_SetRenderDrawColor(renderer, 16, 211, 204, 2);
  SDL_RenderDrawLine(renderer, Oy(A.y), Ox(A.x), Oy(A1.y), Ox(A1.x));
  SDL_RenderDrawLine(renderer, Oy(A1.y), Ox(A1.x), Oy(B1.y), Ox(B1.x));
  SDL_RenderDrawLine(renderer, Oy(B.y), Ox(B.x), Oy(B1.y), Ox(B1.x));

  SDL_RenderDrawLine(renderer, Oy(A.y) + 1, Ox(A.x) + 1, Oy(A1.y) + 1, Ox(A1.x) + 1);
  SDL_RenderDrawLine(renderer, Oy(A1.y) + 1, Ox(A1.x) + 1, Oy(B1.y), Ox(B1.x) + 1);
  SDL_RenderDrawLine(renderer, Oy(B.y) + 1, Ox(B.x) + 1, Oy(B1.y) + 1, Ox(B1.x) + 1);

  SDL_RenderDrawLine(renderer, Oy(A.y) - 1, Ox(A.x) - 1, Oy(A1.y) - 1, Ox(A1.x) - 1);
  SDL_RenderDrawLine(renderer, Oy(A1.y) - 1, Ox(A1.x) - 1, Oy(B1.y) - 1, Ox(B1.x) - 1);
  SDL_RenderDrawLine(renderer, Oy(B.y) - 1, Ox(B.x) - 1, Oy(B1.y) - 1, Ox(B1.x) - 1);
  SDL_RenderPresent(renderer);
  SDL_Delay(100);
}

bool mouse_random(Point A)
{
  if(A.x == 11 && A.y == 4) return true;
  return false;
}

bool mouse_sound(Point A)
{
  if(A.x == 0 && A.y == 18) return true;
  return false;
}

bool mouse_reset(Point A)
{
  if(A.x == 0 && A.y == 19) return true;
  return false;
}

bool mouse_main(Point A)
{
  if(A.x == 0 && A.y == 20) return true;
  return false;
}
//dùng để in hình ảnh background tại vị trí thay đổi
void printRect(Point A)
{
  if(arr[A.x][A.y] > 0) return;
  SDL_Rect rect;
  rect.w = h_w;
  rect.h = h_w;
  rect.x = (A.y - 1) * h_w + const_collum;
  rect.y = (A.x - 1) * h_w + const_row;
  string s = "photos/" + to_string(A.x) + "." + to_string(A.y) + ".png";
  SDL_Texture *abc = loadTexture(s, renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect);
  SDL_DestroyTexture(abc);
}

void print_random()
{
  for(int j = 1; j <= collum - 2; ++ j){
    for(int i = 1; i <= row - 2; ++i){
      SDL_Rect rect;
      rect.w = h_w;
      rect.h = h_w;
      rect.x = (i - 1) * h_w + const_collum;
      rect.y = (j - 1) * h_w + const_row;

      if(arr[j][i] > 0)
      {
        SDL_SetRenderDrawColor(renderer, 223, 103, 83, 0);
        SDL_RenderFillRect(renderer, &rect);

        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderDrawRect(renderer, &rect);

        SDL_Rect rect1;
        rect1.w = h_w - 10;
        rect1.h = h_w - 10;
        rect1.x = (i - 1) * h_w + const_collum + 5;
        rect1.y = (j - 1) * h_w + const_row + 5;
        string s = "1/" + to_string(arr[j][i]) + ".3.png";
        SDL_Texture *abc = loadTexture(s, renderer);
        SDL_RenderCopy(renderer, abc, NULL, &rect1);
        SDL_DestroyTexture(abc);
      }
      else
      {
        printRect({j, i});
      }
    }
  }
  SDL_RenderPresent(renderer);
}

void load_score()
{
  renderTexture("photos/bgr_score.jpg", 950, 150, 130, 60);
  loadFont(to_string(score), 965, 150, 60, 60, 1);
}

void load_turn()
{
  renderTexture("photos/bgr_score.jpg", 975, 310, 130, 60);
  loadFont(to_string(turn), 975, 310, 45, 60, 1);
}

void load_level()
{
  renderTexture("photos/bgr_score.jpg", 975, 470, 130, 60);
  loadFont(to_string(level), 975, 470, 45, 60, 1);
}

load_end()
{
  loadFont("SCORE", 470, 470, 130, 50, 0);
  loadFont(to_string(score), 510, 520, 60, 60, 1);
}

//in map tại thời điểm hiên tại
void printMap()
{
  SDL_RenderClear(renderer);
  background("photos/b1.jpg");
  SDL_Rect rect;
  rect.w = h_w;
  rect.h = h_w;

  for(int j = 1; j <= collum - 2; ++ j){
    for(int i = 1; i <= row - 2; ++i){
      rect.x = (i - 1) * h_w + const_collum;
      rect.y = (j - 1) * h_w + const_row;

      if(arr[j][i] > 0)
      {
        SDL_SetRenderDrawColor(renderer, 223, 103, 83, 0);
        SDL_RenderFillRect(renderer, &rect);
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderDrawRect(renderer, &rect);

        SDL_Rect rect1;
        rect1.w = h_w - 10;
        rect1.h = h_w - 10;
        rect1.x = (i - 1) * h_w + const_collum + 5;
        rect1.y = (j - 1) * h_w + const_row + 5;
        string s = "1/" + to_string(arr[j][i]) + ".3.png";
        SDL_Texture *abc = loadTexture(s, renderer);
        SDL_RenderCopy(renderer, abc, NULL, &rect1);
        SDL_DestroyTexture(abc);
      }
    }
  }
  SDL_RenderPresent(renderer);
  SDL_Rect rect1 = {200, 600, h_w, h_w};

//  SDL_SetRenderDrawColor(renderer, 23, 203, 83, 0);
//  SDL_RenderFillRect(renderer, &rect1);
  SDL_Texture *abc = loadTexture("photos/random.jpg", renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect1);
  SDL_DestroyTexture(abc);

  loadFont("SCORE", 930, 100, 130, 50, 0);
  loadFont("CHANGE TURN", 930, 260, 130, 50, 0);
  loadFont("LEVEL", 930, 420, 130, 50, 0);
  load_score();
  load_turn();
  load_level();
  reset_img();
  main_img();
  sound_img();
  //load_time(time_lv);

  SDL_RenderPresent(renderer);
  //SDL_Delay(100);
}

void lv(Point A, Point B, int n)
{
  switch(n)
  {
    case 1:
      break;

    case 2:
      if(A.y == B.y)
      {
        vector<int> v;
        for(int i = 1; i <= collum - 2; ++i)
        {
          if(arr[i][A.y] > 0)
          {
            v.push_back(arr[i][A.y]);
            arr[i][A.y] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[i][A.y] = v[i - 1];
      }
      else //if(A.x == B.x)
      {
        vector<int> v1, v2;
        for(int i = 1; i <= collum - 2; ++i)
        {
          if(arr[i][A.y] > 0)
          {
            v1.push_back(arr[i][A.y]);
            arr[i][A.y] = 0;
          }
          if(arr[i][B.y] > 0)
          {
            v2.push_back(arr[i][B.y]);
            arr[i][B.y] = 0;
          }
        }
        for(int i = 1; i <= v1.size(); ++i) arr[i][A.y] = v1[i - 1];
        for(int i = 1; i <= v2.size(); ++i) arr[i][B.y] = v2[i - 1];
      }
      print_random();
      break;

    case 3:
      if(A.y == B.y)
      {
        vector<int> v;
        for(int i = 1; i <= collum - 2; ++i)
        {
          if(arr[i][A.y] > 0)
          {
            v.push_back(arr[i][A.y]);
            arr[i][A.y] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[collum - 2 - v.size() + i][A.y] = v[i - 1];
      }
      else //if(A.x == B.x)
      {
        vector<int> v1, v2;
        for(int i = 1; i <= collum - 2; ++i)
        {
          if(arr[i][A.y] > 0)
          {
            v1.push_back(arr[i][A.y]);
            arr[i][A.y] = 0;
          }
          if(arr[i][B.y] > 0)
          {
            v2.push_back(arr[i][B.y]);
            arr[i][B.y] = 0;
          }
        }
        for(int i = 1; i <= v1.size(); ++i) arr[collum - 2 - v1.size() + i][A.y] = v1[i - 1];
        for(int i = 1; i <= v2.size(); ++i) arr[collum - 2 - v2.size() + i][B.y] = v2[i - 1];
      }
      print_random();
      break;

    case 4:
      if(A.x == B.x)
      {
        vector<int> v;
        for(int i = 1; i <= row - 2; ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[A.x][i] = v[i - 1];
      }
      else //if(A.x == B.x)
      {
        vector<int> v1, v2;
        for(int i = 1; i <= row - 2; ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v1.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
          if(arr[B.x][i] > 0)
          {
            v2.push_back(arr[B.x][i]);
            arr[B.x][i] = 0;
          }
        }
        for(int i = 1; i <= v1.size(); ++i) arr[A.x][i] = v1[i - 1];
        for(int i = 1; i <= v2.size(); ++i) arr[B.x][i] = v2[i - 1];
      }
      print_random();
      break;

    case 5:
      if(A.x == B.x)
      {
        vector<int> v;
        for(int i = 1; i <= row - 2; ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[A.x][row - 2 - v.size() + i] = v[i - 1];
      }
      else //if(A.x == B.x)
      {
        vector<int> v1, v2;
        for(int i = 1; i <= row - 2; ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v1.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
          if(arr[B.x][i] > 0)
          {
            v2.push_back(arr[B.x][i]);
            arr[B.x][i] = 0;
          }
        }
        for(int i = 1; i <= v1.size(); ++i) arr[A.x][row - 2 - v1.size() + i] = v1[i - 1];
        for(int i = 1; i <= v2.size(); ++i) arr[B.x][row - 2 - v2.size() + i] = v2[i - 1];
      }
      print_random();
      break;

    case 6:
      if(A.y <= (row - 2) / 2)
      {
        vector<int> v;
        for(int i = 1; i <= (row - 2) / 2; ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[A.x][i] = v[i - 1];
      }
      else
      {
        vector<int> v;
        for(int i = (row - 2) / 2 + 1; i <= (row - 2); ++i)
        {
          if(arr[A.x][i] > 0)
          {
            v.push_back(arr[A.x][i]);
            arr[A.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[A.x][row - 2 - v.size() + i] = v[i - 1];
      }

      if(B.y <= (row - 2) / 2)
      {
        vector<int> v;
        for(int i = 1; i <= (row - 2) / 2; ++i)
        {
          if(arr[B.x][i] > 0)
          {
            v.push_back(arr[B.x][i]);
            arr[B.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[B.x][i] = v[i - 1];
      }
      else
      {
        vector<int> v;
        for(int i = (row - 2) / 2 + 1; i <= (row - 2); ++i)
        {
          if(arr[B.x][i] > 0)
          {
            v.push_back(arr[B.x][i]);
            arr[B.x][i] = 0;
          }
        }
        for(int i = 1; i <= v.size(); ++i) arr[B.x][row - 2 - v.size() + i] = v[i - 1];
      }
      print_random();
      break;

    default: break;
  }
}

void printTurn(Point A, int n)
{
  if(arr[A.x][A.y] == 0) return;
  SDL_Rect rect;
  rect.w = h_w;
  rect.h = h_w;
  rect.x = (A.y - 1) * h_w + const_collum;
  rect.y = (A.x - 1) * h_w + const_row;

  if(n == 0)
  {
    SDL_SetRenderDrawColor(renderer, 223, 103, 83, 0);
    SDL_RenderFillRect(renderer, &rect);
  }
  else
  {
    SDL_SetRenderDrawColor(renderer, 120, 75, 230, 0);
    SDL_RenderFillRect(renderer, &rect);
  }
  SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
  SDL_RenderDrawRect(renderer, &rect);

  rect.w -= 10;
  rect.h -= 10;
  rect.x += 5;
  rect.y += 5;
  string s = "1/" + to_string(arr[A.x][A.y]) + ".3.png";
  SDL_Texture *abc = loadTexture(s, renderer);
  SDL_RenderCopy(renderer, abc, NULL, &rect);
  SDL_RenderPresent(renderer);
  SDL_DestroyTexture(abc);
}

// chỉ in vị trí có thay đổi
void printPoint(Point A, Point B)
{
  pair<Point, Point> p = road(A, B);
  arr[A.x][A.y] = 0;
  arr[B.x][B.y] = 0;
  Point B1 = p.second;
  Point A1 = p.first;
  if(A.x == A1.x)
  {
    for(int i = min(A1.y, A.y); i <= max(A.y, A1.y); ++i) printRect({A.x, i});
  }
  else //if(A.y == A1.y)
  {
    for(int i = min(A1.x, A.x); i <= max(A.x, A1.x); ++i) printRect({i, A.y});
  }

  if(B1.x == A1.x)
  {
    for(int i = min(B1.y, A1.y); i <= max(B1.y, A1.y); ++i) printRect({A1.x, i});
  }
  else //if(B1.y == A1.y)
  {
    for(int i = min(A1.x, B1.x); i <= max(B1.x, A1.x); ++i) printRect({i, A1.y});
  }

  if(B.x == B1.x)
  {
    for(int i = min(B1.y, B.y); i <= max(B1.y, B.y); ++i) printRect({B.x, i});
  }
  else //if(B.y == B1.y)
  {
    for(int i = min(B1.x, B.x); i <= max(B.x, B1.x); ++i) printRect({i, B.y});
  }
}

void printBoard()
{
  for(int i = 0; i < collum; ++i)
  {
    for(int j = 0; j < row; ++j)
    {
      cout << arr[i][j] << " ";
      if(arr[i][j] < 10) cout << "  ";
      else cout << " ";
    }
    cout << endl;
  }
  cout << "---------------------------" << endl << endl;
}

void reset()
{
  Mix_HaltMusic();
  if(sound == 0) Mix_PlayMusic( gMusic, -1 );
  SDL_RenderClear(renderer);
  makeArr();
  score = 0;
  turn = 10;
  level = 1;
  time_lv = lv_time;
  printMap();
  //SDL_Delay(50);
  for(int i = 1; i < 100; ++i) time_end[i] = 0;
  time_end[0] = time(NULL);
  m.clear();
}

void lose_game()
{
  Mix_HaltMusic();
  background("photos/lose.gif");
  load_end();
  //return;
}

void win_game()
{
  Mix_HaltMusic();
  background("photos/won.jpg");
  load_end();
  //return;
}

//chạy chương trình
void level_()
{
  time_end[level - 1] = time(NULL);
  do
  {
    if(turn == 0 && !check_Exit_Pair())
    {
      lose_game();
      break;
    }
    if(!check_Exit_Pair() && turn > 0)
    {
      turn--;
      random();
      printMap();
      load_turn();
      continue;
    }
    if(lose) break;
    Point turn1 = mouse();
    while(turn1.x == -1 || turn1.y == -1)
    {
      turn1 = mouse();
      if(lose) break;
      //return;
      while(mouse_sound(turn1))
      {
        mix();
        turn1 = mouse();
        //continue;
      }
      while(mouse_main(turn1)) turn1 = mouse();
      while(turn == 0 && mouse_random(turn1)) turn1 = mouse();
    }

    if(mouse_random(turn1)) {
      turn--;
      random();
      print_random();
      load_turn();
      continue;
    }
    else if(mouse_reset(turn1))
    {
      reset();
      level_();
    }
    else if(check) printTurn(turn1, 1);
    if(lose) break;

    Point turn2 = mouse();
    while(turn2.x == -1 || turn2.y == -1)
    {
      turn2 = mouse();
      if(lose)
      {
        break;
        //return;
      }
      while(mouse_sound(turn2))
      {
        mix();
        turn2 = mouse();
      }
      while(mouse_main(turn2)) turn2 = mouse();
      while(turn == 0 && mouse_random(turn2)) turn2 = mouse();
    }

    if(mouse_random(turn2)) {
      turn--;
      random();
      print_random();
      load_turn();
      continue;
    }
    else if(mouse_reset(turn2))
    {
      reset();
      level_();
    }
    else if(check) printTurn(turn2, 1);
    if(lose) break;

    if(checkX(turn1, turn2).size() != 0 || checkY(turn1, turn2).size() != 0)
    {
      loadChunk();
      print_Road(turn1, turn2);
      SDL_Delay(100);
      printPoint(turn1, turn2);
      lv(turn1, turn2, level);
      score += 10 + (level - 1) * 2;
      load_score();
    }
    else if(check)
    {
      printTurn(turn1, 0);
      printTurn(turn2, 0);
    }
    if(isGameOver())
    {
      time_end[level] = time(NULL);
      score += (time_end[level] - time_end[level - 1]) * (7 + (level - 1) * 2) / 10;
      if(level < 6)
      {
        SDL_RenderClear(renderer);
        m.clear();
        makeArr();
        level++;
        turn = min(10, turn + 1);
        time_lv = lv_time + 20 * (level - 1);
        printMap();
      }
      else
      {
        win_game();
        break;
      }
    }
  } while(!isGameOver() && !lose);
  if(lose)
  {
    lose_game();
  }
}

void play_game()
{
  printMap();
  loadMedia();
  level_();
  //return;
}

//màn hình menu vào game
void start()
{
  SDL_RenderClear(renderer);

  SDL_Texture *background = loadTexture("photos/background_start.png", renderer);
  SDL_Texture *start= loadTexture("photos/start.png", renderer);
  if(background == nullptr || start == nullptr) {
    SDL_DestroyTexture(background);
    SDL_DestroyTexture(start);
    quitSDL(window, renderer);
  }

  SDL_Rect rect = {0, 0, SCREEN_WIDTH, SCREEN_HEIGHT};
  SDL_RenderCopy(renderer, background, NULL, &rect);

  SDL_Rect rect1 = {345, 450, 460, 180};
  SDL_RenderCopy(renderer, start, NULL, &rect1);
  SDL_RenderPresent(renderer);

  loadFont_start();

  SDL_Event e;
  while(SDL_WaitEvent(&e))
  {
    bool check = false;
    if(e.type == SDL_QUIT)
    {
      SDL_Quit();
    }
    if(e.type == SDL_MOUSEBUTTONUP)
    {
      int x = e.button.x;
      int y = e.button.y;
      if(x >= rect1.x && y >= rect1.y && y <= rect1.y + rect.h && x <= rect1.x + rect1.w)
      {
        play_game();
        check = true;
      }
      //break;
    }
    if(check) break;
  }
  SDL_DestroyTexture(background);
  SDL_DestroyTexture(start);
}

int main(int argc, char* argv[])
{
  ios_base::sync_with_stdio(false);

  initSDL(window, renderer);
  SDL_RenderClear(renderer);

  makeArr();
  start();

  SDL_RenderPresent(renderer);
  waitUntilKeyPressed();
  quitSDL(window, renderer);
  return 0;
}
